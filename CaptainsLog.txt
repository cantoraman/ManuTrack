django-admin startproject ManuTrack
git init
add readme.md
python manage.py runserver
-log http://127.0.0.1:8000/

python manage.py startapp jobs
add basic view to views
create urls.py to map url reqs

at urls OF JOBS:
import path from djangourls
import views in the current level
set the '' path to point views.index

at Urls of ROOT
add include to include own packages
aaaaand include the jobs.url on the url patterns
>
The include() function allows referencing other URLconfs. Whenever Django encounters include(), it chops off whatever part of the URL matched up to that point and sends the remaining string to the included URLconf for further processing.

set the timezone to UTC at settings.py

python manage.py migrate to set the DB

>sqlite3 enters sqlite console / ctrl D exits

start creating classes/models

app is done, add it to settings.py @ root
in apps=> 'jobs.apps.JobConfig',

make migrations = python manage.py makemigrations jobs

then migrate = python manage.py migrate

--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
In the playground I was a little bit clumsy. So, let's make a recap:

Enter the shell with
    python manage.py shell

import all of your models
    from jobs.models import Designer, Manufacturer, Job

crete an instance of your model

m = Manufacturer(manufacturer_name="Hasan")

this instantiates it but does not save it to the database
to save it:

m.save()

now, m.id will show its id

d = Designer(designer_name="Sevtap")
d.save()

Designer.objects.all()   -will now bring all of our designers

To create a job:
from django.utils import timezone
t=timezone.now()
d.job_set.create(manufacturer=m, (other information optional) ,creation_date = t, start_date=t,completion_date=t,rejection_date=t)

In [49]: Job.objects.all()[0].completion_date
Out[49]: datetime.datetime(2019, 2, 8, 7, 45, 17, 519401, tzinfo=<UTC>)

In [50]: Job.objects.all()
Out[50]: <QuerySet [<Job: >, <Job: >]>


And whenever you change the models, always do, makemigrations on the app (job) and do migrate

In [24]: Job.objects.filter(job_client__startswith='ef')
Out[24]: <QuerySet [<Job: >, <Job: >]>

In [19]: Job.objects.filter(id=1)
Out[19]: <QuerySet [<Job: >]>


In [18]: [manu.manufacturer.manufacturer_name for manu in Job.objects.all()[:]]
Out[18]: ['Hasan', 'Hasan', 'kutay']

                    # Django provides a rich database lookup API that's entirely driven by
                    # keyword arguments.
                    >>> Question.objects.filter(id=1)
                    <QuerySet [<Question: What's up?>]>
                    >>> Question.objects.filter(question_text__startswith='What')
                    <QuerySet [<Question: What's up?>]>

                    # Get the question that was published this year.
                    >>> from django.utils import timezone
                    >>> current_year = timezone.now().year
                    >>> Question.objects.get(pub_date__year=current_year)
                    # Lookup by a primary key is the most common case, so Django provides a
                    # shortcut for primary-key exact lookups.
                    # The following is identical to Question.objects.get(id=1).
                    >>> Question.objects.get(pk=1)
                    <Question: What's up?>

                    # Make sure our custom method worked.
                    >>> q = Question.objects.get(pk=1)



In [32]: m.job_set.all()
Out[32]: <QuerySet [<Job: >]>

In [33]: m.job_set.count()
Out[33]: 1

In [36]: Job.objects.filter(manufacturer__manufacturer_name__startswith='H')
Out[36]: <QuerySet [<Job: >, <Job: >]>

In [37]: Job.objects.filter(manufacturer__manufacturer_name__startswith='K')
Out[37]: <QuerySet [<Job: >]>

In [42]: kutayinisi= Job.objects.filter(manufacturer__manufacturer_name__startswith='K')

In [43]: kutayinisi
Out[43]: <QuerySet [<Job: >]>

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> so, if you represent an entry with a variable, and call delete on that variable...
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> this deletes the data from the db


In [47]: kutayinisi.delete()
Out[47]: (1, {'jobs.Job': 1})

In [48]: kutayinisi
Out[48]: <QuerySet []>

----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------------------------


Now time for admin stuff
create an admin account

python manage.py createsuperuser

but also, let's make our models modifiable in the panel
to do this
go to admin.py
from .models import Job, Manufacturer, Designer
admin.site.register([Job,Manufacturer, Designer])


>>>>>>>>>

Now lets design some views

but before, lets create some HTML templates for the views
create templates and templates/jobs directories and index.html template

in the HTML template:
             {% if active_jobs_list %}
                 <ul>
            {% for active_job in active_jobs_list %}
                  <li><a href="/jobs/{{active_job.id}}/">{{ active_job.job_description }}</a></li>
            {% endfor %}
                 </ul>
    {% else %}
        <p>No Jobs for you</p>
    {% endif %}

this will help us

>>> now go to views to add the template to the http response with its python payload >>>>>>
but wait... it is very common. So we have a shortcut:


[removes loader being imported and HTTPResponse too]

def index(request):
    active_jobs = Job.objects.filter(is_completed=False)
    context = {
        'active_jobs_list': active_jobs,
    }
    return render(request, 'jobs/index.html', context)

And lets make sure we have an '' (empty) path at urlpatterns

urlpatterns = [
    path('', views.index, name='index'),
]

------

now lets add exception handling to the details

from django.http import Http404
def job_detail(request, job_id):
    try:
        job = Job.objects.get(pk=job_id)
    except Job.DoesNotExist:
        raise Http404('The job you are looking for does not exist')
    return render(request, 'jobs/detail.html', {'job': job})

Create a template html called job_details.html
and basically fill it with essential stuff

Now:
    when we do this, there are some good stuff we can use from the django's template language
    it doesn't just allow python code to be executed in the template
    but it does have some nice shortcuts
    google it

{{ name|lower }}
{{ some_text|escape|linebreaks }}
{{ bio|truncatewords:50 }}
{{ some_list|join:", "}}
{{ string_or_a_list|length}}
{{ file_size_in_bytes|filesizeformat }} -byte->x.x MB or xxx Bytes



::::::::::::::::
at this stage I dived into template inheritance subject which is a powerful tool to keep the code dry

I'll follow the considerate code's tutorial on mobile chrome
Note1:
The cycle follows this pattern
visit jobs/title
url pattern invokes views.add_title
add_title renders 'jobs/title.html'
title.html sees that it need a base.html, calls base.html and nests itself there

Note2:
first check the guys git repo to see where he keeps the html's
::::::::::::::::::::

Back again on 19th of Feb... made a get_object_or_404 for designer
I kept the first exception for educational purposes

Before proceeding with template inheritance,
lets remove hardcoded urls in the lists

first add app_name to urls.py so that django can tell the difference between other apps in our projects

<li><a href="/jobs/{{active_job.id}}/">{{ active_job.job_description }}</a></li>

has become

<li><a href=" {% url 'jobs:job detail' active_job.id %}">{{ active_job.job_description }}</a></li>












and let's connect them to url patterns

















.